const { leftMargin } = require('./configuration');
const configuration = require('./configuration');
const imageSizeOf = require('image-size');
const { Utils } = require('./Utils');

class ReportSections extends Utils{
    constructor({pdf, sections, startingIndex}) {
        super({pdf});
        this.render(sections, startingIndex);
        const { outline } = this.pdf;
    }

    renderSection(section, prefixIndex, outline, headerFontSize = configuration.size.font.header, headerFontColor=configuration.color.header ){
        const keys = Object.keys(section);
        let createdOutline = null;
        for(const key of keys){
            switch (key) {
                case 'header':
                    const headerValue = `${prefixIndex} ${section['header']}`;
                    createdOutline = outline.addItem(headerValue);
                    this.pdf.fillColor(headerFontColor).font(configuration.font.bold).fontSize(headerFontSize).text(headerValue, { align: 'left' });
                    break;
                case 'description':
                    this.pdf.fillColor(configuration.color.regular).font(configuration.font.regular).fontSize(configuration.size.font.regular);
                    for(const description of section[key]){
                        const stringHeight = this.pdf.heightOfString(description);
                        this.checkNewPage(stringHeight);
                        this.pdf.text(description, { align: 'justify' });
                        this.pdf.moveDown()
                    }
                    break;
                case 'table':
                    for(const row of section[key]['rows']){
                        const keyHeight = this.pdf.heightOfString(row['key']);
                        this.checkNewPage(keyHeight);

                        const valueHeight = this.pdf.heightOfString(row['value']);
                        this.checkNewPage(valueHeight);
                        
                        this.tableRow({ 
                            key: row['key'],
                            value: row['value'],
                            firstColumnWidth: section[key]['firstColumnWidth'],
                            keyColor: row['header'] ? configuration.color.subHeader: 'black',
                            valueColor: row['header'] ? configuration.color.subHeader: 'black',
                            font: row['header'] ? configuration.font.bold: configuration.font.regular
                        })
                    }
                    this.pdf.moveDown()
                    break;
                case 'list':
                    this.pdf.list(section[key],{indent: 20, bulletIndent:20, textIndent:20});
                    this.pdf.moveDown()
                    break;
                default:
                    break;
            }
        }
        return {
            createdOutline: createdOutline,
        }
    }

    render(sections, startingIndex){
        for(const section of sections){
            this.addNewPage();
            const { outline } = this.pdf;

            const out = this.renderSection(section, startingIndex, outline);

            let subIndex = 0;
            for(const subsection of section['subSections']){
                subIndex++;
                this.renderSection(subsection, `${startingIndex}.${subIndex}`, out.createdOutline, configuration.size.font.title, configuration.color.subHeader);
            }   
            startingIndex++;
        }
    }
}

module.exports = {
    ReportSections: ReportSections,
}