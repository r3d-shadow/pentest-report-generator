const { leftMargin } = require('./configuration');
const configuration = require('./configuration');
const imageSizeOf = require('image-size');
const { Utils } = require('./Utils');

class Vulnerabilities extends Utils{
    constructor({pdf, vulnerabilities, categorized, startingIndex}) {
        super({pdf});
        return this.render(vulnerabilities, categorized, startingIndex)
    }

    categorizeVulnerabilities(vulnerabilities){
        const categorizedVulnerabilities = { Critical: [], High: [], Medium: [], Low: [] };
        vulnerabilities.forEach((vulnerability) => {
            switch (vulnerability.severity.toLowerCase()) {
                case 'critical':
                vulnerability['color'] = '#c00000';
                categorizedVulnerabilities.Critical.push(vulnerability);
                break;
                case 'high':
                vulnerability['color'] = '#ff0000';
                categorizedVulnerabilities.High.push(vulnerability);
                break;
                case 'medium':
                vulnerability['color'] = '#ed7d31';
                categorizedVulnerabilities.Medium.push(vulnerability);
                break;
                case 'low':
                vulnerability['color'] = '#70ad47';
                categorizedVulnerabilities.Low.push(vulnerability);
                break;
                default:
                throw new Error("Invalid Severity");
                break;
            }
        });
        return categorizedVulnerabilities;
    };

    renderVulnerability(vulnerability, index, indexPrefix, vulnerabilityOutline){
        let startX = this.pdf.x;
        let startY = this.pdf.y;

        const vulnerabilityValue =  `${indexPrefix}${index} ${vulnerability.title}`;
        vulnerabilityOutline.addItem(vulnerabilityValue);
        
        this.pdf.fillColor(configuration.color.subHeader).font(configuration.font.bold).fontSize(configuration.size.font.title).text(vulnerabilityValue, { align: 'left' });
        this.pdf.moveDown();

        // ------------------------------ Table: START -----------------------------------
        this.tableRow({ 
            key: 'Description',
            value: vulnerability.description
        })

        this.tableRow({ 
            key: 'Severity',
            value: vulnerability.severity
        })

        this.tableRow({ 
            key: 'Impact',
            value: vulnerability.impact
        })

        this.tableRow({ 
            key: 'System',
            value: vulnerability.system
        })

        this.tableRow({ 
            key: 'Recommendation',
            value: vulnerability.recommendation
        })
        this.pdf.moveDown();
        // ------------------------------ Table: END -----------------------------------

        // ------------------------------ POC: END -----------------------------------
        this.pdf.fillColor(configuration.color.regular).font(configuration.font.bold).fontSize(configuration.size.font.regular).text(`Evidence of the defect:`, { align: 'left' });
        this.pdf.moveDown();

        this.pdf.fillColor(configuration.color.regular).font(configuration.font.regular).fontSize(configuration.size.font.regular);
        for(const poc of vulnerability.poc){

            let pocHeight = 0;
            const titlePresent = poc.title && poc.title !== "";
            const descriptionPresent = poc.description && poc.description !== "";
            if(titlePresent){
                pocHeight += this.pdf.heightOfString(`${poc.title}`);
            }
            if(descriptionPresent){
                pocHeight += this.pdf.heightOfString(`${poc.description}`);
            }
            this.checkNewPage(pocHeight);

            if(titlePresent){
                this.pdf.fillColor(configuration.color.regular).font(configuration.font.boldItalic).fontSize(configuration.size.font.regular);
                this.pdf.text(`${poc.title}`, { align: 'left' });
                this.pdf.fillColor(configuration.color.regular).font(configuration.font.regular).fontSize(configuration.size.font.regular);
            }
            if(descriptionPresent){
                this.pdf.text(`${poc.description}`, { align: 'justify' });
            }

            for(const figure of poc.figures){
                const dimensions = imageSizeOf(figure.figure);
                const imageRenderedHeight = dimensions.height/dimensions.width * configuration.size.pocImage.width;
                pocHeight = 0;
                pocHeight += this.pdf.heightOfString(`${figure.description}`);
                pocHeight += imageRenderedHeight;
                pocHeight += this.pdf.currentLineHeight(); // For movedown
                pocHeight += this.pdf.currentLineHeight(); // For movedown

                this.checkNewPage(pocHeight);

                this.pdf.text(`${figure.description}`, { align: 'justify' });
                this.pdf.moveDown();
                let imageX = configuration.pageWidth - configuration.size.pocImage.width - configuration.margins.left - configuration.margins.right;
                this.pdf.image(figure.figure, this.pdf.x + imageX/2, this.pdf.y, {width: configuration.size.pocImage.width}).stroke();

                this.pdf.y += imageRenderedHeight;
                
                this.pdf.moveDown();
            }
        }
        // ------------------------------ POC: END -----------------------------------
    }

    renderFindingsSummary(vulnerabilities, categorized, startingIndex) {
        let vulnerabilityIndex = 0;
        const { outline } = this.pdf;
        const vulnerabilitiesSummaryValue = `${startingIndex} Vulnerabilities Summary`
        const vulnerabilitiesSummaryOutline = outline.addItem(vulnerabilitiesSummaryValue);
        this.pdf.fillColor(configuration.color.title).font(configuration.font.bold).fontSize(configuration.size.font.header).text(vulnerabilitiesSummaryValue, { align: 'left' });
        this.pdf.moveDown()
        this.tableRow({ 
            key: 'Severity',
            value: 'Vulnerability',
            keyColor: configuration.color.subHeader,
            valueColor: configuration.color.subHeader,
            font: configuration.font.bold,
        })
        if(categorized === true){
            const categorizedVulnerabilities = this.categorizeVulnerabilities(vulnerabilities);
            for (const severity in categorizedVulnerabilities) {
                categorizedVulnerabilities[severity].forEach((vulnerability) => {
                    vulnerabilityIndex++;
                    this.tableRow({ 
                        key: vulnerability.severity,
                        value: `${vulnerability.title}`,
                        keyColor: vulnerability['color'],
                    })
                })
            }
        }else{
            vulnerabilities.forEach((vulnerability) => {
                vulnerabilityIndex++;
                this.tableRow({ 
                    key: vulnerability.severity,
                    value: vulnerability.title
                })
            });
        }
        return true
    }

    renderVulnerabilityList(vulnerabilities, vulnerabilityIndex, vulnerabilityIndexPrefix, vulnerabilityOutline) {
        vulnerabilities.forEach((vulnerability, index) => {
            vulnerabilityIndex++;
            this.renderVulnerability(vulnerability, vulnerabilityIndex, vulnerabilityIndexPrefix, vulnerabilityOutline);
            if(index+1 < vulnerabilities.length){
                this.addNewPage();
            }
        });
        return vulnerabilityIndex;
    }

    render(vulnerabilities, categorized, startingIndex){
        this.addNewPage();
        const { outline } = this.pdf;

        let vulnerabilityIndex = 0;
        let vulnerabilityIndexPrefix = "Vulnerability #";
        this.renderFindingsSummary(vulnerabilities, categorized, startingIndex);
        let currentIndex = startingIndex;
        if(categorized === true){
            let severityStartingIndex = startingIndex + 1;
            const categorizedVulnerabilities = this.categorizeVulnerabilities(vulnerabilities);

            const categorizedVulnerabilityKeys = Object.keys(categorizedVulnerabilities);
            categorizedVulnerabilityKeys.forEach((severity, index) => {
                if(categorizedVulnerabilities[severity].length > 0){
                    this.addNewPage();
                    const severityHeader = `${severityStartingIndex} ${severity} Severity Vulnerabilities`;
                    const vulnerabilityOutline = outline.addItem(severityHeader);
                    this.pdf.fillColor(configuration.color.title).font(configuration.font.bold).fontSize(configuration.size.font.header).text(severityHeader, { align: 'left' });
                    this.pdf.moveDown();
                    vulnerabilityIndex = 0;
                    vulnerabilityIndexPrefix = `${severityStartingIndex}.`;
                    vulnerabilityIndex = this.renderVulnerabilityList(categorizedVulnerabilities[severity], vulnerabilityIndex, vulnerabilityIndexPrefix, vulnerabilityOutline)
                    severityStartingIndex++;
                }
            });
            currentIndex = severityStartingIndex;
        }else{
            this.addNewPage();
            const vulnerabilityHeader = `Vulnerabilities`;
            const vulnerabilityOutline = outline.addItem(vulnerabilityHeader);
            vulnerabilityIndex = this.renderVulnerabilityList(vulnerabilities, vulnerabilityIndex, vulnerabilityIndexPrefix, vulnerabilityOutline)
            currentIndex = startingIndex;
        }
        return {
            currentIndex: currentIndex
        }
    }
}

module.exports = {
    Vulnerabilities: Vulnerabilities,
}